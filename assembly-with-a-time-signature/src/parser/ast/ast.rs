#![allow(unused)]
#![allow(non_snake_case)]
#![allow(non_camel_case_types)]
#![allow(clippy::all)]
// |==========================================================|
// |      WARNING: THIS FILE IS AUTOMATICALLY GENERATED.      |
// |      CHANGES TO IT WILL BE DELETED WHEN REGENERATED.     |
// | IN GENERAL, THIS FILE SHOULD NOT BE MODIFIED IN ANY WAY. |
// |==========================================================|
use super::prelude::*;
#[derive(Debug, PartialEq)]
pub struct Program<M>(pub M, pub Vec<LabelOrInstr<M>>);
#[derive(Debug, PartialEq)]
pub enum LabelOrInstr<M> {
    Instruction(M, Instruction<M>),
    Label(M, Label<M>),
    Combined(M, Label<M>, Instruction<M>),
    Section(M, Section<M>),
    Newline(M),
}
#[derive(Debug, PartialEq)]
pub enum Instruction<M> {
    Call(M, Operand<M>),
    CallAsync(M, Operand<M>),
    Ret(M),
    RetAsync(M),
    Jmp(M, Operand<M>),
    Bpm(M, Operand<M>),
    Time(M, Operand<M>, Operand<M>),
    Beat(M),
    Wait(M, Operand<M>),
    PlayOne(M, Operand<M>),
    Play(M, Operand<M>, Operand<M>),
    Flat(M, Note<M>),
    Sharp(M, Note<M>),
    Push(M, Operand<M>),
    Pop(M, Register<M>),
    Add(M, Register<M>, Operand<M>, Operand<M>),
    Sub(M, Register<M>, Operand<M>, Operand<M>),
    Inc(M, Register<M>),
    Dec(M, Register<M>),
    Jg(M, Operand<M>, Operand<M>, Operand<M>),
    Jl(M, Operand<M>, Operand<M>, Operand<M>),
    Jge(M, Operand<M>, Operand<M>, Operand<M>),
    Jle(M, Operand<M>, Operand<M>, Operand<M>),
    Jeq(M, Operand<M>, Operand<M>, Operand<M>),
    Je(M, Operand<M>, Operand<M>, Operand<M>),
    Jne(M, Operand<M>, Operand<M>, Operand<M>),
    Mov(M, Register<M>, Operand<M>),
    St(M, Operand<M>, Operand<M>),
    Ld(M, Register<M>, Operand<M>),
    Define(M, Instrument<M>),
    Lir(M, Operand<M>),
    Stop(M),
}
#[derive(Debug, PartialEq)]
pub enum Label<M> {
    Global(M, Identifier<M>),
    Local(M, Int<M>),
}
#[derive(Debug, PartialEq)]
pub struct Section<M>(pub M, pub Identifier<M>);
#[derive(Debug, PartialEq)]
pub enum Operand<M> {
    LabelRef(M, Identifier<M>),
    Int(M, Int<M>),
    Note(M, Note<M>),
    Register(M, Register<M>),
}
#[derive(Debug, PartialEq)]
pub struct Note<M>(pub M, pub std::string::String);
#[derive(Debug, PartialEq)]
pub struct Register<M>(pub M, pub RegisterName<M>);
#[derive(Debug, PartialEq)]
pub enum Instrument<M> {
    Custom(M, Int<M>),
    Piano(M),
    Celesta(M),
    Glockenspiel(M),
    Musicbox(M),
    Marimba(M),
    Dulcimer(M),
    Organ(M),
    Accordion(M),
    Harmonica(M),
    Nylonguitar(M),
    Steelguitar(M),
    Distortionguitar(M),
    Acousticbass(M),
    Slapbass(M),
    Violin(M),
    Harp(M),
    Timpani(M),
    Strings(M),
    Synthstrings(M),
    Voiceoohs(M),
    Synthvox(M),
    Brass(M),
    Altosax(M),
    Tenorsax(M),
    Oboe(M),
    Enghorn(M),
    Flute(M),
    Panflute(M),
    Whistle(M),
    Ocarina(M),
    Heavysquarewave(M),
    Fantasia(M),
    Warmpad(M),
    Echodrops(M),
    Startheme(M),
    Sitar(M),
    Banjo(M),
    Kalimba(M),
    Bagpipe(M),
    Fiddle(M),
    Steeldrum(M),
    Bird(M),
    Telephone(M),
    Applause(M),
    Gunshot(M),
}
#[derive(Debug, PartialEq)]
pub struct Identifier<M>(pub M, pub std::string::String);
#[derive(Debug, PartialEq)]
pub struct Int<M>(pub M, pub std::string::String);
#[derive(Debug, PartialEq)]
pub enum RegisterName<M> {
    Br(M),
    Bt(M),
    Pc(M),
    Sp(M),
    Ir(M),
    Oc(M),
    Accidental(M, Note<M>),
    Num(M, std::string::String),
    Note(M, std::string::String),
}
#[derive(Debug, PartialEq)]
pub enum Layout<M> {
    Simple(M, std::string::String),
    Comment(M, Vec<std::string::String>),
}
pub type AST_ROOT<M> = Program<M>;
