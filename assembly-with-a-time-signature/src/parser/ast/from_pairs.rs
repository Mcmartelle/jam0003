#![allow(unused)]
#![allow(non_snake_case)]
#![allow(non_camel_case_types)]
#![allow(clippy::all)]
// |==========================================================|
// |      WARNING: THIS FILE IS AUTOMATICALLY GENERATED.      |
// |      CHANGES TO IT WILL BE DELETED WHEN REGENERATED.     |
// | IN GENERAL, THIS FILE SHOULD NOT BE MODIFIED IN ANY WAY. |
// |==========================================================|
use super::prelude::*;
impl<M: AstInfo> FromPairs<M> for Program<M> {
    fn from_pairs<G: GenerateAstInfo<Result = M>>(pair: &ParsePairSort, generator: &mut G) -> Self {
        assert!(
            vec!["program"].contains(&pair.sort),
            "{} not in {:?}",
            pair.sort,
            vec!["program"]
        );
        let info = generator.generate(&pair);
        Self(
            info,
            if let ParsePairExpression::List(_, ref l) = pair.constructor_value {
                l . iter () . map (| x | if let ParsePairExpression :: Sort (_ , ref s) = x { LabelOrInstr :: from_pairs (s , generator) } else { unreachable ! ("expected different parse pair expression in pair to ast conversion of {}" , "program") ; }) . collect ()
            } else {
                unreachable!(
                    "expected different parse pair expression in pair to ast conversion of {}",
                    "program"
                );
            },
        )
    }
}
impl<M: AstInfo> FromPairs<M> for LabelOrInstr<M> {
    fn from_pairs<G: GenerateAstInfo<Result = M>>(pair: &ParsePairSort, generator: &mut G) -> Self {
        assert!(
            vec!["label-or-instr"].contains(&pair.sort),
            "{} not in {:?}",
            pair.sort,
            vec!["label-or-instr"]
        );
        let info = generator.generate(&pair);
        match pair.constructor_name {
            "instruction" => {
                if let ParsePairExpression::List(_, ref l) = pair.constructor_value {
                    Self::Instruction(
                        info,
                        if let ParsePairExpression::Sort(_, ref s) = l[0usize] {
                            Instruction::from_pairs(s, generator)
                        } else {
                            unreachable ! ("expected different parse pair expression in pair to ast conversion of {}" , "label-or-instr");
                        },
                    )
                } else {
                    unreachable!(
                        "expected different parse pair expression in pair to ast conversion of {}",
                        "label-or-instr"
                    );
                }
            }
            "label" => {
                if let ParsePairExpression::List(_, ref l) = pair.constructor_value {
                    Self::Label(
                        info,
                        if let ParsePairExpression::Sort(_, ref s) = l[0usize] {
                            Label::from_pairs(s, generator)
                        } else {
                            unreachable ! ("expected different parse pair expression in pair to ast conversion of {}" , "label-or-instr");
                        },
                    )
                } else {
                    unreachable!(
                        "expected different parse pair expression in pair to ast conversion of {}",
                        "label-or-instr"
                    );
                }
            }
            "combined" => {
                if let ParsePairExpression::List(_, ref l) = pair.constructor_value {
                    Self::Combined(
                        info,
                        if let ParsePairExpression::Sort(_, ref s) = l[0usize] {
                            Label::from_pairs(s, generator)
                        } else {
                            unreachable ! ("expected different parse pair expression in pair to ast conversion of {}" , "label-or-instr");
                        },
                        if let ParsePairExpression::Sort(_, ref s) = l[1usize] {
                            Instruction::from_pairs(s, generator)
                        } else {
                            unreachable ! ("expected different parse pair expression in pair to ast conversion of {}" , "label-or-instr");
                        },
                    )
                } else {
                    unreachable!(
                        "expected different parse pair expression in pair to ast conversion of {}",
                        "label-or-instr"
                    );
                }
            }
            "section" => {
                if let ParsePairExpression::List(_, ref l) = pair.constructor_value {
                    Self::Section(
                        info,
                        if let ParsePairExpression::Sort(_, ref s) = l[0usize] {
                            Section::from_pairs(s, generator)
                        } else {
                            unreachable ! ("expected different parse pair expression in pair to ast conversion of {}" , "label-or-instr");
                        },
                    )
                } else {
                    unreachable!(
                        "expected different parse pair expression in pair to ast conversion of {}",
                        "label-or-instr"
                    );
                }
            }
            "newline" => Self::Newline(info),
            a => unreachable!("{}", a),
        }
    }
}
impl<M: AstInfo> FromPairs<M> for Instruction<M> {
    fn from_pairs<G: GenerateAstInfo<Result = M>>(pair: &ParsePairSort, generator: &mut G) -> Self {
        assert!(
            vec!["instruction"].contains(&pair.sort),
            "{} not in {:?}",
            pair.sort,
            vec!["instruction"]
        );
        let info = generator.generate(&pair);
        match pair.constructor_name {
            "call" => {
                if let ParsePairExpression::List(_, ref l) = pair.constructor_value {
                    Self::Call(
                        info,
                        if let ParsePairExpression::Sort(_, ref s) = l[1usize] {
                            Operand::from_pairs(s, generator)
                        } else {
                            unreachable ! ("expected different parse pair expression in pair to ast conversion of {}" , "instruction");
                        },
                    )
                } else {
                    unreachable!(
                        "expected different parse pair expression in pair to ast conversion of {}",
                        "instruction"
                    );
                }
            }
            "call_async" => {
                if let ParsePairExpression::List(_, ref l) = pair.constructor_value {
                    Self::CallAsync(
                        info,
                        if let ParsePairExpression::Sort(_, ref s) = l[1usize] {
                            Operand::from_pairs(s, generator)
                        } else {
                            unreachable ! ("expected different parse pair expression in pair to ast conversion of {}" , "instruction");
                        },
                    )
                } else {
                    unreachable!(
                        "expected different parse pair expression in pair to ast conversion of {}",
                        "instruction"
                    );
                }
            }
            "ret" => Self::Ret(info),
            "ret_async" => Self::RetAsync(info),
            "jmp" => {
                if let ParsePairExpression::List(_, ref l) = pair.constructor_value {
                    Self::Jmp(
                        info,
                        if let ParsePairExpression::Sort(_, ref s) = l[1usize] {
                            Operand::from_pairs(s, generator)
                        } else {
                            unreachable ! ("expected different parse pair expression in pair to ast conversion of {}" , "instruction");
                        },
                    )
                } else {
                    unreachable!(
                        "expected different parse pair expression in pair to ast conversion of {}",
                        "instruction"
                    );
                }
            }
            "bpm" => {
                if let ParsePairExpression::List(_, ref l) = pair.constructor_value {
                    Self::Bpm(
                        info,
                        if let ParsePairExpression::Sort(_, ref s) = l[1usize] {
                            Operand::from_pairs(s, generator)
                        } else {
                            unreachable ! ("expected different parse pair expression in pair to ast conversion of {}" , "instruction");
                        },
                    )
                } else {
                    unreachable!(
                        "expected different parse pair expression in pair to ast conversion of {}",
                        "instruction"
                    );
                }
            }
            "time" => {
                if let ParsePairExpression::List(_, ref l) = pair.constructor_value {
                    Self::Time(
                        info,
                        if let ParsePairExpression::Sort(_, ref s) = l[1usize] {
                            Operand::from_pairs(s, generator)
                        } else {
                            unreachable ! ("expected different parse pair expression in pair to ast conversion of {}" , "instruction");
                        },
                        if let ParsePairExpression::Sort(_, ref s) = l[2usize] {
                            Operand::from_pairs(s, generator)
                        } else {
                            unreachable ! ("expected different parse pair expression in pair to ast conversion of {}" , "instruction");
                        },
                    )
                } else {
                    unreachable!(
                        "expected different parse pair expression in pair to ast conversion of {}",
                        "instruction"
                    );
                }
            }
            "beat" => Self::Beat(info),
            "wait" => {
                if let ParsePairExpression::List(_, ref l) = pair.constructor_value {
                    Self::Wait(
                        info,
                        if let ParsePairExpression::Sort(_, ref s) = l[1usize] {
                            Operand::from_pairs(s, generator)
                        } else {
                            unreachable ! ("expected different parse pair expression in pair to ast conversion of {}" , "instruction");
                        },
                    )
                } else {
                    unreachable!(
                        "expected different parse pair expression in pair to ast conversion of {}",
                        "instruction"
                    );
                }
            }
            "play_one" => {
                if let ParsePairExpression::List(_, ref l) = pair.constructor_value {
                    Self::PlayOne(
                        info,
                        if let ParsePairExpression::Sort(_, ref s) = l[1usize] {
                            Operand::from_pairs(s, generator)
                        } else {
                            unreachable ! ("expected different parse pair expression in pair to ast conversion of {}" , "instruction");
                        },
                    )
                } else {
                    unreachable!(
                        "expected different parse pair expression in pair to ast conversion of {}",
                        "instruction"
                    );
                }
            }
            "play" => {
                if let ParsePairExpression::List(_, ref l) = pair.constructor_value {
                    Self::Play(
                        info,
                        if let ParsePairExpression::Sort(_, ref s) = l[1usize] {
                            Operand::from_pairs(s, generator)
                        } else {
                            unreachable ! ("expected different parse pair expression in pair to ast conversion of {}" , "instruction");
                        },
                        if let ParsePairExpression::Sort(_, ref s) = l[2usize] {
                            Operand::from_pairs(s, generator)
                        } else {
                            unreachable ! ("expected different parse pair expression in pair to ast conversion of {}" , "instruction");
                        },
                    )
                } else {
                    unreachable!(
                        "expected different parse pair expression in pair to ast conversion of {}",
                        "instruction"
                    );
                }
            }
            "flat" => {
                if let ParsePairExpression::List(_, ref l) = pair.constructor_value {
                    Self::Flat(
                        info,
                        if let ParsePairExpression::Sort(_, ref s) = l[1usize] {
                            Note::from_pairs(s, generator)
                        } else {
                            unreachable ! ("expected different parse pair expression in pair to ast conversion of {}" , "instruction");
                        },
                    )
                } else {
                    unreachable!(
                        "expected different parse pair expression in pair to ast conversion of {}",
                        "instruction"
                    );
                }
            }
            "sharp" => {
                if let ParsePairExpression::List(_, ref l) = pair.constructor_value {
                    Self::Sharp(
                        info,
                        if let ParsePairExpression::Sort(_, ref s) = l[1usize] {
                            Note::from_pairs(s, generator)
                        } else {
                            unreachable ! ("expected different parse pair expression in pair to ast conversion of {}" , "instruction");
                        },
                    )
                } else {
                    unreachable!(
                        "expected different parse pair expression in pair to ast conversion of {}",
                        "instruction"
                    );
                }
            }
            "push" => {
                if let ParsePairExpression::List(_, ref l) = pair.constructor_value {
                    Self::Push(
                        info,
                        if let ParsePairExpression::Sort(_, ref s) = l[1usize] {
                            Operand::from_pairs(s, generator)
                        } else {
                            unreachable ! ("expected different parse pair expression in pair to ast conversion of {}" , "instruction");
                        },
                    )
                } else {
                    unreachable!(
                        "expected different parse pair expression in pair to ast conversion of {}",
                        "instruction"
                    );
                }
            }
            "pop" => {
                if let ParsePairExpression::List(_, ref l) = pair.constructor_value {
                    Self::Pop(
                        info,
                        if let ParsePairExpression::Sort(_, ref s) = l[1usize] {
                            Register::from_pairs(s, generator)
                        } else {
                            unreachable ! ("expected different parse pair expression in pair to ast conversion of {}" , "instruction");
                        },
                    )
                } else {
                    unreachable!(
                        "expected different parse pair expression in pair to ast conversion of {}",
                        "instruction"
                    );
                }
            }
            "add" => {
                if let ParsePairExpression::List(_, ref l) = pair.constructor_value {
                    Self::Add(
                        info,
                        if let ParsePairExpression::Sort(_, ref s) = l[1usize] {
                            Register::from_pairs(s, generator)
                        } else {
                            unreachable ! ("expected different parse pair expression in pair to ast conversion of {}" , "instruction");
                        },
                        if let ParsePairExpression::Sort(_, ref s) = l[2usize] {
                            Operand::from_pairs(s, generator)
                        } else {
                            unreachable ! ("expected different parse pair expression in pair to ast conversion of {}" , "instruction");
                        },
                        if let ParsePairExpression::Sort(_, ref s) = l[3usize] {
                            Operand::from_pairs(s, generator)
                        } else {
                            unreachable ! ("expected different parse pair expression in pair to ast conversion of {}" , "instruction");
                        },
                    )
                } else {
                    unreachable!(
                        "expected different parse pair expression in pair to ast conversion of {}",
                        "instruction"
                    );
                }
            }
            "sub" => {
                if let ParsePairExpression::List(_, ref l) = pair.constructor_value {
                    Self::Sub(
                        info,
                        if let ParsePairExpression::Sort(_, ref s) = l[1usize] {
                            Register::from_pairs(s, generator)
                        } else {
                            unreachable ! ("expected different parse pair expression in pair to ast conversion of {}" , "instruction");
                        },
                        if let ParsePairExpression::Sort(_, ref s) = l[2usize] {
                            Operand::from_pairs(s, generator)
                        } else {
                            unreachable ! ("expected different parse pair expression in pair to ast conversion of {}" , "instruction");
                        },
                        if let ParsePairExpression::Sort(_, ref s) = l[3usize] {
                            Operand::from_pairs(s, generator)
                        } else {
                            unreachable ! ("expected different parse pair expression in pair to ast conversion of {}" , "instruction");
                        },
                    )
                } else {
                    unreachable!(
                        "expected different parse pair expression in pair to ast conversion of {}",
                        "instruction"
                    );
                }
            }
            "inc" => {
                if let ParsePairExpression::List(_, ref l) = pair.constructor_value {
                    Self::Inc(
                        info,
                        if let ParsePairExpression::Sort(_, ref s) = l[1usize] {
                            Register::from_pairs(s, generator)
                        } else {
                            unreachable ! ("expected different parse pair expression in pair to ast conversion of {}" , "instruction");
                        },
                    )
                } else {
                    unreachable!(
                        "expected different parse pair expression in pair to ast conversion of {}",
                        "instruction"
                    );
                }
            }
            "dec" => {
                if let ParsePairExpression::List(_, ref l) = pair.constructor_value {
                    Self::Dec(
                        info,
                        if let ParsePairExpression::Sort(_, ref s) = l[1usize] {
                            Register::from_pairs(s, generator)
                        } else {
                            unreachable ! ("expected different parse pair expression in pair to ast conversion of {}" , "instruction");
                        },
                    )
                } else {
                    unreachable!(
                        "expected different parse pair expression in pair to ast conversion of {}",
                        "instruction"
                    );
                }
            }
            "jg" => {
                if let ParsePairExpression::List(_, ref l) = pair.constructor_value {
                    Self::Jg(
                        info,
                        if let ParsePairExpression::Sort(_, ref s) = l[1usize] {
                            Operand::from_pairs(s, generator)
                        } else {
                            unreachable ! ("expected different parse pair expression in pair to ast conversion of {}" , "instruction");
                        },
                        if let ParsePairExpression::Sort(_, ref s) = l[2usize] {
                            Operand::from_pairs(s, generator)
                        } else {
                            unreachable ! ("expected different parse pair expression in pair to ast conversion of {}" , "instruction");
                        },
                        if let ParsePairExpression::Sort(_, ref s) = l[3usize] {
                            Operand::from_pairs(s, generator)
                        } else {
                            unreachable ! ("expected different parse pair expression in pair to ast conversion of {}" , "instruction");
                        },
                    )
                } else {
                    unreachable!(
                        "expected different parse pair expression in pair to ast conversion of {}",
                        "instruction"
                    );
                }
            }
            "jl" => {
                if let ParsePairExpression::List(_, ref l) = pair.constructor_value {
                    Self::Jl(
                        info,
                        if let ParsePairExpression::Sort(_, ref s) = l[1usize] {
                            Operand::from_pairs(s, generator)
                        } else {
                            unreachable ! ("expected different parse pair expression in pair to ast conversion of {}" , "instruction");
                        },
                        if let ParsePairExpression::Sort(_, ref s) = l[2usize] {
                            Operand::from_pairs(s, generator)
                        } else {
                            unreachable ! ("expected different parse pair expression in pair to ast conversion of {}" , "instruction");
                        },
                        if let ParsePairExpression::Sort(_, ref s) = l[3usize] {
                            Operand::from_pairs(s, generator)
                        } else {
                            unreachable ! ("expected different parse pair expression in pair to ast conversion of {}" , "instruction");
                        },
                    )
                } else {
                    unreachable!(
                        "expected different parse pair expression in pair to ast conversion of {}",
                        "instruction"
                    );
                }
            }
            "jge" => {
                if let ParsePairExpression::List(_, ref l) = pair.constructor_value {
                    Self::Jge(
                        info,
                        if let ParsePairExpression::Sort(_, ref s) = l[1usize] {
                            Operand::from_pairs(s, generator)
                        } else {
                            unreachable ! ("expected different parse pair expression in pair to ast conversion of {}" , "instruction");
                        },
                        if let ParsePairExpression::Sort(_, ref s) = l[2usize] {
                            Operand::from_pairs(s, generator)
                        } else {
                            unreachable ! ("expected different parse pair expression in pair to ast conversion of {}" , "instruction");
                        },
                        if let ParsePairExpression::Sort(_, ref s) = l[3usize] {
                            Operand::from_pairs(s, generator)
                        } else {
                            unreachable ! ("expected different parse pair expression in pair to ast conversion of {}" , "instruction");
                        },
                    )
                } else {
                    unreachable!(
                        "expected different parse pair expression in pair to ast conversion of {}",
                        "instruction"
                    );
                }
            }
            "jle" => {
                if let ParsePairExpression::List(_, ref l) = pair.constructor_value {
                    Self::Jle(
                        info,
                        if let ParsePairExpression::Sort(_, ref s) = l[1usize] {
                            Operand::from_pairs(s, generator)
                        } else {
                            unreachable ! ("expected different parse pair expression in pair to ast conversion of {}" , "instruction");
                        },
                        if let ParsePairExpression::Sort(_, ref s) = l[2usize] {
                            Operand::from_pairs(s, generator)
                        } else {
                            unreachable ! ("expected different parse pair expression in pair to ast conversion of {}" , "instruction");
                        },
                        if let ParsePairExpression::Sort(_, ref s) = l[3usize] {
                            Operand::from_pairs(s, generator)
                        } else {
                            unreachable ! ("expected different parse pair expression in pair to ast conversion of {}" , "instruction");
                        },
                    )
                } else {
                    unreachable!(
                        "expected different parse pair expression in pair to ast conversion of {}",
                        "instruction"
                    );
                }
            }
            "jeq" => {
                if let ParsePairExpression::List(_, ref l) = pair.constructor_value {
                    Self::Jeq(
                        info,
                        if let ParsePairExpression::Sort(_, ref s) = l[1usize] {
                            Operand::from_pairs(s, generator)
                        } else {
                            unreachable ! ("expected different parse pair expression in pair to ast conversion of {}" , "instruction");
                        },
                        if let ParsePairExpression::Sort(_, ref s) = l[2usize] {
                            Operand::from_pairs(s, generator)
                        } else {
                            unreachable ! ("expected different parse pair expression in pair to ast conversion of {}" , "instruction");
                        },
                        if let ParsePairExpression::Sort(_, ref s) = l[3usize] {
                            Operand::from_pairs(s, generator)
                        } else {
                            unreachable ! ("expected different parse pair expression in pair to ast conversion of {}" , "instruction");
                        },
                    )
                } else {
                    unreachable!(
                        "expected different parse pair expression in pair to ast conversion of {}",
                        "instruction"
                    );
                }
            }
            "je" => {
                if let ParsePairExpression::List(_, ref l) = pair.constructor_value {
                    Self::Je(
                        info,
                        if let ParsePairExpression::Sort(_, ref s) = l[1usize] {
                            Operand::from_pairs(s, generator)
                        } else {
                            unreachable ! ("expected different parse pair expression in pair to ast conversion of {}" , "instruction");
                        },
                        if let ParsePairExpression::Sort(_, ref s) = l[2usize] {
                            Operand::from_pairs(s, generator)
                        } else {
                            unreachable ! ("expected different parse pair expression in pair to ast conversion of {}" , "instruction");
                        },
                        if let ParsePairExpression::Sort(_, ref s) = l[3usize] {
                            Operand::from_pairs(s, generator)
                        } else {
                            unreachable ! ("expected different parse pair expression in pair to ast conversion of {}" , "instruction");
                        },
                    )
                } else {
                    unreachable!(
                        "expected different parse pair expression in pair to ast conversion of {}",
                        "instruction"
                    );
                }
            }
            "jne" => {
                if let ParsePairExpression::List(_, ref l) = pair.constructor_value {
                    Self::Jne(
                        info,
                        if let ParsePairExpression::Sort(_, ref s) = l[1usize] {
                            Operand::from_pairs(s, generator)
                        } else {
                            unreachable ! ("expected different parse pair expression in pair to ast conversion of {}" , "instruction");
                        },
                        if let ParsePairExpression::Sort(_, ref s) = l[2usize] {
                            Operand::from_pairs(s, generator)
                        } else {
                            unreachable ! ("expected different parse pair expression in pair to ast conversion of {}" , "instruction");
                        },
                        if let ParsePairExpression::Sort(_, ref s) = l[3usize] {
                            Operand::from_pairs(s, generator)
                        } else {
                            unreachable ! ("expected different parse pair expression in pair to ast conversion of {}" , "instruction");
                        },
                    )
                } else {
                    unreachable!(
                        "expected different parse pair expression in pair to ast conversion of {}",
                        "instruction"
                    );
                }
            }
            "mov" => {
                if let ParsePairExpression::List(_, ref l) = pair.constructor_value {
                    Self::Mov(
                        info,
                        if let ParsePairExpression::Sort(_, ref s) = l[1usize] {
                            Register::from_pairs(s, generator)
                        } else {
                            unreachable ! ("expected different parse pair expression in pair to ast conversion of {}" , "instruction");
                        },
                        if let ParsePairExpression::Sort(_, ref s) = l[2usize] {
                            Operand::from_pairs(s, generator)
                        } else {
                            unreachable ! ("expected different parse pair expression in pair to ast conversion of {}" , "instruction");
                        },
                    )
                } else {
                    unreachable!(
                        "expected different parse pair expression in pair to ast conversion of {}",
                        "instruction"
                    );
                }
            }
            "st" => {
                if let ParsePairExpression::List(_, ref l) = pair.constructor_value {
                    Self::St(
                        info,
                        if let ParsePairExpression::Sort(_, ref s) = l[1usize] {
                            Operand::from_pairs(s, generator)
                        } else {
                            unreachable ! ("expected different parse pair expression in pair to ast conversion of {}" , "instruction");
                        },
                        if let ParsePairExpression::Sort(_, ref s) = l[2usize] {
                            Operand::from_pairs(s, generator)
                        } else {
                            unreachable ! ("expected different parse pair expression in pair to ast conversion of {}" , "instruction");
                        },
                    )
                } else {
                    unreachable!(
                        "expected different parse pair expression in pair to ast conversion of {}",
                        "instruction"
                    );
                }
            }
            "ld" => {
                if let ParsePairExpression::List(_, ref l) = pair.constructor_value {
                    Self::Ld(
                        info,
                        if let ParsePairExpression::Sort(_, ref s) = l[1usize] {
                            Register::from_pairs(s, generator)
                        } else {
                            unreachable ! ("expected different parse pair expression in pair to ast conversion of {}" , "instruction");
                        },
                        if let ParsePairExpression::Sort(_, ref s) = l[2usize] {
                            Operand::from_pairs(s, generator)
                        } else {
                            unreachable ! ("expected different parse pair expression in pair to ast conversion of {}" , "instruction");
                        },
                    )
                } else {
                    unreachable!(
                        "expected different parse pair expression in pair to ast conversion of {}",
                        "instruction"
                    );
                }
            }
            "define" => {
                if let ParsePairExpression::List(_, ref l) = pair.constructor_value {
                    Self::Define(
                        info,
                        if let ParsePairExpression::Sort(_, ref s) = l[1usize] {
                            Instrument::from_pairs(s, generator)
                        } else {
                            unreachable ! ("expected different parse pair expression in pair to ast conversion of {}" , "instruction");
                        },
                    )
                } else {
                    unreachable!(
                        "expected different parse pair expression in pair to ast conversion of {}",
                        "instruction"
                    );
                }
            }
            "lir" => {
                if let ParsePairExpression::List(_, ref l) = pair.constructor_value {
                    Self::Lir(
                        info,
                        if let ParsePairExpression::Sort(_, ref s) = l[1usize] {
                            Operand::from_pairs(s, generator)
                        } else {
                            unreachable ! ("expected different parse pair expression in pair to ast conversion of {}" , "instruction");
                        },
                    )
                } else {
                    unreachable!(
                        "expected different parse pair expression in pair to ast conversion of {}",
                        "instruction"
                    );
                }
            }
            "stop" => Self::Stop(info),
            a => unreachable!("{}", a),
        }
    }
}
impl<M: AstInfo> FromPairs<M> for Label<M> {
    fn from_pairs<G: GenerateAstInfo<Result = M>>(pair: &ParsePairSort, generator: &mut G) -> Self {
        assert!(
            vec!["label"].contains(&pair.sort),
            "{} not in {:?}",
            pair.sort,
            vec!["label"]
        );
        let info = generator.generate(&pair);
        match pair.constructor_name {
            "global" => {
                if let ParsePairExpression::List(_, ref l) = pair.constructor_value {
                    Self::Global(
                        info,
                        if let ParsePairExpression::Sort(_, ref s) = l[0usize] {
                            Identifier::from_pairs(s, generator)
                        } else {
                            unreachable ! ("expected different parse pair expression in pair to ast conversion of {}" , "label");
                        },
                    )
                } else {
                    unreachable!(
                        "expected different parse pair expression in pair to ast conversion of {}",
                        "label"
                    );
                }
            }
            "local" => {
                if let ParsePairExpression::List(_, ref l) = pair.constructor_value {
                    Self::Local(
                        info,
                        if let ParsePairExpression::Sort(_, ref s) = l[1usize] {
                            Int::from_pairs(s, generator)
                        } else {
                            unreachable ! ("expected different parse pair expression in pair to ast conversion of {}" , "label");
                        },
                    )
                } else {
                    unreachable!(
                        "expected different parse pair expression in pair to ast conversion of {}",
                        "label"
                    );
                }
            }
            a => unreachable!("{}", a),
        }
    }
}
impl<M: AstInfo> FromPairs<M> for Section<M> {
    fn from_pairs<G: GenerateAstInfo<Result = M>>(pair: &ParsePairSort, generator: &mut G) -> Self {
        assert!(
            vec!["section"].contains(&pair.sort),
            "{} not in {:?}",
            pair.sort,
            vec!["section"]
        );
        let info = generator.generate(&pair);
        if let ParsePairExpression::List(_, ref l) = pair.constructor_value {
            Self(
                info,
                if let ParsePairExpression::Sort(_, ref s) = l[1usize] {
                    Identifier::from_pairs(s, generator)
                } else {
                    unreachable!(
                        "expected different parse pair expression in pair to ast conversion of {}",
                        "section"
                    );
                },
            )
        } else {
            unreachable!(
                "expected different parse pair expression in pair to ast conversion of {}",
                "section"
            );
        }
    }
}
impl<M: AstInfo> FromPairs<M> for Operand<M> {
    fn from_pairs<G: GenerateAstInfo<Result = M>>(pair: &ParsePairSort, generator: &mut G) -> Self {
        assert!(
            vec!["operand"].contains(&pair.sort),
            "{} not in {:?}",
            pair.sort,
            vec!["operand"]
        );
        let info = generator.generate(&pair);
        match pair.constructor_name {
            "label-ref" => {
                Self::LabelRef(
                    info,
                    if let ParsePairExpression::Sort(_, ref s) = pair.constructor_value {
                        Identifier::from_pairs(s, generator)
                    } else {
                        unreachable ! ("expected different parse pair expression in pair to ast conversion of {}" , "operand");
                    },
                )
            }
            "int" => {
                Self::Int(
                    info,
                    if let ParsePairExpression::Sort(_, ref s) = pair.constructor_value {
                        Int::from_pairs(s, generator)
                    } else {
                        unreachable ! ("expected different parse pair expression in pair to ast conversion of {}" , "operand");
                    },
                )
            }
            "note" => {
                Self::Note(
                    info,
                    if let ParsePairExpression::Sort(_, ref s) = pair.constructor_value {
                        Note::from_pairs(s, generator)
                    } else {
                        unreachable ! ("expected different parse pair expression in pair to ast conversion of {}" , "operand");
                    },
                )
            }
            "register" => {
                Self::Register(
                    info,
                    if let ParsePairExpression::Sort(_, ref s) = pair.constructor_value {
                        Register::from_pairs(s, generator)
                    } else {
                        unreachable ! ("expected different parse pair expression in pair to ast conversion of {}" , "operand");
                    },
                )
            }
            a => unreachable!("{}", a),
        }
    }
}
impl<M: AstInfo> FromPairs<M> for Note<M> {
    fn from_pairs<G: GenerateAstInfo<Result = M>>(pair: &ParsePairSort, generator: &mut G) -> Self {
        assert!(
            vec!["note"].contains(&pair.sort),
            "{} not in {:?}",
            pair.sort,
            vec!["note"]
        );
        let info = generator.generate(&pair);
        if let ParsePairExpression::List(_, ref l) = pair.constructor_value {
            Self(
                info,
                if let ParsePairExpression::Empty(ref span) = l[1usize] {
                    span.as_str().to_string()
                } else {
                    unreachable!(
                        "expected different parse pair expression in pair to ast conversion of {}",
                        "note"
                    );
                },
            )
        } else {
            unreachable!(
                "expected different parse pair expression in pair to ast conversion of {}",
                "note"
            );
        }
    }
}
impl<M: AstInfo> FromPairs<M> for Register<M> {
    fn from_pairs<G: GenerateAstInfo<Result = M>>(pair: &ParsePairSort, generator: &mut G) -> Self {
        assert!(
            vec!["register"].contains(&pair.sort),
            "{} not in {:?}",
            pair.sort,
            vec!["register"]
        );
        let info = generator.generate(&pair);
        if let ParsePairExpression::List(_, ref l) = pair.constructor_value {
            Self(
                info,
                if let ParsePairExpression::Sort(_, ref s) = l[1usize] {
                    RegisterName::from_pairs(s, generator)
                } else {
                    unreachable!(
                        "expected different parse pair expression in pair to ast conversion of {}",
                        "register"
                    );
                },
            )
        } else {
            unreachable!(
                "expected different parse pair expression in pair to ast conversion of {}",
                "register"
            );
        }
    }
}
impl<M: AstInfo> FromPairs<M> for Instrument<M> {
    fn from_pairs<G: GenerateAstInfo<Result = M>>(pair: &ParsePairSort, generator: &mut G) -> Self {
        assert!(
            vec!["instrument"].contains(&pair.sort),
            "{} not in {:?}",
            pair.sort,
            vec!["instrument"]
        );
        let info = generator.generate(&pair);
        match pair.constructor_name {
            "custom" => {
                Self::Custom(
                    info,
                    if let ParsePairExpression::Sort(_, ref s) = pair.constructor_value {
                        Int::from_pairs(s, generator)
                    } else {
                        unreachable ! ("expected different parse pair expression in pair to ast conversion of {}" , "instrument");
                    },
                )
            }
            "piano" => Self::Piano(info),
            "celesta" => Self::Celesta(info),
            "glockenspiel" => Self::Glockenspiel(info),
            "musicbox" => Self::Musicbox(info),
            "marimba" => Self::Marimba(info),
            "dulcimer" => Self::Dulcimer(info),
            "organ" => Self::Organ(info),
            "accordion" => Self::Accordion(info),
            "harmonica" => Self::Harmonica(info),
            "nylonguitar" => Self::Nylonguitar(info),
            "steelguitar" => Self::Steelguitar(info),
            "distortionguitar" => Self::Distortionguitar(info),
            "acousticbass" => Self::Acousticbass(info),
            "slapbass" => Self::Slapbass(info),
            "violin" => Self::Violin(info),
            "harp" => Self::Harp(info),
            "timpani" => Self::Timpani(info),
            "strings" => Self::Strings(info),
            "synthstrings" => Self::Synthstrings(info),
            "voiceoohs" => Self::Voiceoohs(info),
            "synthvox" => Self::Synthvox(info),
            "brass" => Self::Brass(info),
            "altosax" => Self::Altosax(info),
            "tenorsax" => Self::Tenorsax(info),
            "oboe" => Self::Oboe(info),
            "enghorn" => Self::Enghorn(info),
            "flute" => Self::Flute(info),
            "panflute" => Self::Panflute(info),
            "whistle" => Self::Whistle(info),
            "ocarina" => Self::Ocarina(info),
            "heavysquarewave" => Self::Heavysquarewave(info),
            "fantasia" => Self::Fantasia(info),
            "warmpad" => Self::Warmpad(info),
            "echodrops" => Self::Echodrops(info),
            "startheme" => Self::Startheme(info),
            "sitar" => Self::Sitar(info),
            "banjo" => Self::Banjo(info),
            "kalimba" => Self::Kalimba(info),
            "bagpipe" => Self::Bagpipe(info),
            "fiddle" => Self::Fiddle(info),
            "steeldrum" => Self::Steeldrum(info),
            "bird" => Self::Bird(info),
            "telephone" => Self::Telephone(info),
            "applause" => Self::Applause(info),
            "gunshot" => Self::Gunshot(info),
            a => unreachable!("{}", a),
        }
    }
}
impl<M: AstInfo> FromPairs<M> for Identifier<M> {
    fn from_pairs<G: GenerateAstInfo<Result = M>>(pair: &ParsePairSort, generator: &mut G) -> Self {
        assert!(
            vec!["identifier"].contains(&pair.sort),
            "{} not in {:?}",
            pair.sort,
            vec!["identifier"]
        );
        let info = generator.generate(&pair);
        return Self(info, pair.constructor_value.span().as_str().to_string());
    }
}
impl<M: AstInfo> FromPairs<M> for Int<M> {
    fn from_pairs<G: GenerateAstInfo<Result = M>>(pair: &ParsePairSort, generator: &mut G) -> Self {
        assert!(
            vec!["int"].contains(&pair.sort),
            "{} not in {:?}",
            pair.sort,
            vec!["int"]
        );
        let info = generator.generate(&pair);
        return Self(info, pair.constructor_value.span().as_str().to_string());
    }
}
impl<M: AstInfo> FromPairs<M> for RegisterName<M> {
    fn from_pairs<G: GenerateAstInfo<Result = M>>(pair: &ParsePairSort, generator: &mut G) -> Self {
        assert!(
            vec!["register-name"].contains(&pair.sort),
            "{} not in {:?}",
            pair.sort,
            vec!["register-name"]
        );
        let info = generator.generate(&pair);
        match pair.constructor_name {
            "br" => Self::Br(info),
            "bt" => Self::Bt(info),
            "pc" => Self::Pc(info),
            "sp" => Self::Sp(info),
            "ir" => Self::Ir(info),
            "oc" => Self::Oc(info),
            "accidental" => {
                if let ParsePairExpression::List(_, ref l) = pair.constructor_value {
                    Self::Accidental(
                        info,
                        if let ParsePairExpression::Sort(_, ref s) = l[1usize] {
                            Note::from_pairs(s, generator)
                        } else {
                            unreachable ! ("expected different parse pair expression in pair to ast conversion of {}" , "register-name");
                        },
                    )
                } else {
                    unreachable!(
                        "expected different parse pair expression in pair to ast conversion of {}",
                        "register-name"
                    );
                }
            }
            "num" => {
                if let ParsePairExpression::List(_, ref l) = pair.constructor_value {
                    Self::Num(
                        info,
                        if let ParsePairExpression::Empty(ref span) = l[1usize] {
                            span.as_str().to_string()
                        } else {
                            unreachable ! ("expected different parse pair expression in pair to ast conversion of {}" , "register-name");
                        },
                    )
                } else {
                    unreachable!(
                        "expected different parse pair expression in pair to ast conversion of {}",
                        "register-name"
                    );
                }
            }
            "note" => {
                if let ParsePairExpression::List(_, ref l) = pair.constructor_value {
                    Self::Note(
                        info,
                        if let ParsePairExpression::Empty(ref span) = l[1usize] {
                            span.as_str().to_string()
                        } else {
                            unreachable ! ("expected different parse pair expression in pair to ast conversion of {}" , "register-name");
                        },
                    )
                } else {
                    unreachable!(
                        "expected different parse pair expression in pair to ast conversion of {}",
                        "register-name"
                    );
                }
            }
            a => unreachable!("{}", a),
        }
    }
}
impl<M: AstInfo> FromPairs<M> for Layout<M> {
    fn from_pairs<G: GenerateAstInfo<Result = M>>(pair: &ParsePairSort, generator: &mut G) -> Self {
        assert!(
            vec!["layout"].contains(&pair.sort),
            "{} not in {:?}",
            pair.sort,
            vec!["layout"]
        );
        let info = generator.generate(&pair);
        match pair.constructor_name {
            "simple" => {
                Self::Simple(
                    info,
                    if let ParsePairExpression::Empty(ref span) = pair.constructor_value {
                        span.as_str().to_string()
                    } else {
                        unreachable ! ("expected different parse pair expression in pair to ast conversion of {}" , "layout");
                    },
                )
            }
            "comment" => {
                if let ParsePairExpression::List(_, ref l) = pair.constructor_value {
                    Self::Comment(
                        info,
                        if let ParsePairExpression::List(_, ref l) = l[1usize] {
                            l . iter () . map (| x | if let ParsePairExpression :: Empty (ref span) = x { span . as_str () . to_string () } else { unreachable ! ("expected different parse pair expression in pair to ast conversion of {}" , "layout") ; }) . collect ()
                        } else {
                            unreachable ! ("expected different parse pair expression in pair to ast conversion of {}" , "layout");
                        },
                    )
                } else {
                    unreachable!(
                        "expected different parse pair expression in pair to ast conversion of {}",
                        "layout"
                    );
                }
            }
            a => unreachable!("{}", a),
        }
    }
}
